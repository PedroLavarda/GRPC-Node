"use strict";
/*
 * Copyright 2023 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListenerResourceType = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const environment_1 = require("../environment");
const resources_1 = require("../resources");
const xds_resource_type_1 = require("./xds-resource-type");
const http_filter_1 = require("../http-filter");
const route_config_resource_type_1 = require("./route-config-resource-type");
const cidr_1 = require("../cidr");
const cross_product_1 = require("../cross-product");
const TRACER_NAME = 'xds_client';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
const ROUTER_FILTER_URL = 'type.googleapis.com/envoy.extensions.filters.http.router.v3.Router';
function normalizedFilterChainMatchEquals(first, second) {
    return (first.destinationPort === second.destinationPort &&
        (0, cidr_1.cidrRangeEqual)(first.prefixRange, second.prefixRange) &&
        first.sourceType === second.sourceType &&
        (0, cidr_1.cidrRangeEqual)(first.sourcePrefixRange, second.sourcePrefixRange) &&
        first.sourcePort === second.sourcePort &&
        first.serverName === second.serverName &&
        first.transportProtocol === second.transportProtocol &&
        first.applicationProtocol === second.applicationProtocol);
}
function normalizeFilterChainMatch(filterChainMatch) {
    const prefixRanges = filterChainMatch.prefix_ranges.map(cidr_1.cidrRangeMessageToCidrRange).map(cidr_1.normalizeCidrRange);
    const sourcePrefixRanges = filterChainMatch.source_prefix_ranges.map(cidr_1.cidrRangeMessageToCidrRange).map(cidr_1.normalizeCidrRange);
    const sourcePorts = filterChainMatch.source_ports;
    const serverNames = filterChainMatch.server_names;
    const applicationProtocols = filterChainMatch.application_protocols;
    const fieldCrossProduct = (0, cross_product_1.crossProduct)([prefixRanges, sourcePrefixRanges, sourcePorts, serverNames, applicationProtocols]);
    return fieldCrossProduct.map(([prefixRange, sourcePrefixRange, sourcePort, serverName, applicationProtocol]) => ({
        destinationPort: filterChainMatch.destination_port?.value,
        prefixRange,
        sourceType: filterChainMatch.source_type,
        sourcePrefixRange,
        sourcePort,
        serverName,
        transportProtocol: filterChainMatch.transport_protocol,
        applicationProtocol: applicationProtocol
    }));
}
function validateHttpConnectionManager(httpConnectionManager) {
    if (environment_1.EXPERIMENTAL_FAULT_INJECTION) {
        const filterNames = new Set();
        for (const [index, httpFilter] of httpConnectionManager.http_filters.entries()) {
            if (filterNames.has(httpFilter.name)) {
                trace('LDS response validation failed: duplicate HTTP filter name ' + httpFilter.name);
                return false;
            }
            filterNames.add(httpFilter.name);
            if (!(0, http_filter_1.validateTopLevelFilter)(httpFilter)) {
                trace('LDS response validation failed: ' + httpFilter.name + ' filter validation failed');
                return false;
            }
            /* Validate that the last filter, and only the last filter, is the
             * router filter. */
            const filterUrl = (0, http_filter_1.getTopLevelFilterUrl)(httpFilter.typed_config);
            if (index < httpConnectionManager.http_filters.length - 1) {
                if (filterUrl === ROUTER_FILTER_URL) {
                    trace('LDS response validation failed: router filter is before end of list');
                    return false;
                }
            }
            else {
                if (filterUrl !== ROUTER_FILTER_URL) {
                    trace('LDS response validation failed: final filter is ' + filterUrl);
                    return false;
                }
            }
        }
    }
    switch (httpConnectionManager.route_specifier) {
        case 'rds':
            if (!httpConnectionManager.rds?.config_source?.ads && !httpConnectionManager.rds?.config_source?.self) {
                return false;
            }
            break;
        case 'route_config':
            if (!route_config_resource_type_1.RouteConfigurationResourceType.get().validateResource(httpConnectionManager.route_config)) {
                return false;
            }
            break;
        default: return false;
    }
    return true;
}
function validateFilterChain(filterChain) {
    if (filterChain.filters.length !== 1) {
        return false;
    }
    if (filterChain.filters[0].typed_config?.type_url !== resources_1.HTTP_CONNECTION_MANGER_TYPE_URL) {
        return false;
    }
    const httpConnectionManager = (0, resources_1.decodeSingleResource)(resources_1.HTTP_CONNECTION_MANGER_TYPE_URL, filterChain.filters[0].typed_config.value);
    if (!validateHttpConnectionManager(httpConnectionManager)) {
        return false;
    }
    return true;
}
class ListenerResourceType extends xds_resource_type_1.XdsResourceType {
    constructor() {
        super();
    }
    static get() {
        return ListenerResourceType.singleton;
    }
    getTypeUrl() {
        return 'envoy.config.listener.v3.Listener';
    }
    validateResource(message) {
        if (!(message.api_listener?.api_listener &&
            message.api_listener.api_listener.type_url === resources_1.HTTP_CONNECTION_MANGER_TYPE_URL)) {
            return null;
        }
        const httpConnectionManager = (0, resources_1.decodeSingleResource)(resources_1.HTTP_CONNECTION_MANGER_TYPE_URL, message.api_listener.api_listener.value);
        if (!validateHttpConnectionManager(httpConnectionManager)) {
            return null;
        }
        if (message.listener_filters.length > 0) {
            return null;
        }
        if (message.use_original_dst?.value === true) {
            return null;
        }
        const seenMatches = [];
        for (const filterChain of message.filter_chains) {
            if (filterChain.filter_chain_match) {
                const normalizedMatches = normalizeFilterChainMatch(filterChain.filter_chain_match);
                for (const match of normalizedMatches) {
                    if (seenMatches.some(prevMatch => normalizedFilterChainMatchEquals(match, prevMatch))) {
                        return null;
                    }
                    seenMatches.push(match);
                }
            }
            if (!validateFilterChain(filterChain)) {
                return null;
            }
        }
        if (message.default_filter_chain && !validateFilterChain(message.default_filter_chain)) {
            return null;
        }
        return message;
    }
    decode(context, resource) {
        if (resource.type_url !== resources_1.LDS_TYPE_URL) {
            throw new Error(`ADS Error: Invalid resource type ${resource.type_url}, expected ${resources_1.LDS_TYPE_URL}`);
        }
        const message = (0, resources_1.decodeSingleResource)(resources_1.LDS_TYPE_URL, resource.value);
        trace('Decoded raw resource of type ' + resources_1.LDS_TYPE_URL + ': ' + JSON.stringify(message, (key, value) => (value && value.type === 'Buffer' && Array.isArray(value.data)) ? value.data.map(n => n.toString(16)).join('') : value, 2));
        const validatedMessage = this.validateResource(message);
        if (validatedMessage) {
            return {
                name: validatedMessage.name,
                value: validatedMessage
            };
        }
        else {
            return {
                name: message.name,
                error: 'Listener message validation failed'
            };
        }
    }
    allResourcesRequiredInSotW() {
        return true;
    }
    static startWatch(client, name, watcher) {
        client.watchResource(ListenerResourceType.get(), name, watcher);
    }
    static cancelWatch(client, name, watcher) {
        client.cancelResourceWatch(ListenerResourceType.get(), name, watcher);
    }
}
exports.ListenerResourceType = ListenerResourceType;
ListenerResourceType.singleton = new ListenerResourceType();
//# sourceMappingURL=listener-resource-type.js.map